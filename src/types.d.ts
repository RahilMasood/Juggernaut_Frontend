// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}

interface PlanningContext {
  readSection: (companyName: string, sectionKey: string) => Promise<any>;
  saveSection: (
    companyName: string,
    sectionKey: string,
    content: unknown,
  ) => Promise<{ ok: boolean }>;
  readCombinedData: () => Promise<any>;
}

interface DocumentMetadata {
  id: string;
  fileName: string;
  fileSize: number;
  uploadTimestamp: number;
  category: string;
  mimeType: string;
  extension: string;
  thumbnailPath?: string;
  contextId?: string;
  contextLabel?: string;
  groupKey?: string;
}

interface DocumentsContext {
  list: () => Promise<DocumentMetadata[]>;
  acceptedTypes: () => Promise<string[]>;
  upload: (
    filePaths: string[],
    category: string,
    context?: { contextId?: string; contextLabel?: string; groupKey?: string },
  ) => Promise<{ ok: boolean; document?: DocumentMetadata; error?: string }[]>;
  delete: (id: string) => Promise<{ ok: boolean }>;
  download: (id: string) => Promise<{ ok: boolean; filePath?: string }>;
  open: (id: string) => Promise<{ ok: boolean }>;
  onProgress: (
    handler: (payload: {
      id: string;
      progress: number;
      status: "uploading" | "success" | "error";
      error?: string;
      fileName?: string;
      fileSize?: number;
      extension?: string;
      category?: string;
      contextId?: string;
      contextLabel?: string;
      groupKey?: string;
    }) => void,
  ) => () => void;
}

interface InternalControlsContext {
  readTemplate: () => Promise<any>;
}

interface CloudFileEntry {
  name: string;
  reference: string;
}

interface CloudUploadRequest {
  container: string;
  filePath: string;
  reference?: string;
}

interface CloudDownloadRequest {
  container: string;
  filename: string;
  downloadPath: string;
}

interface CloudListRequest {
  container: string;
}

interface CloudDeleteRequest {
  container: string;
  filename: string;
}

interface CloudUploadResult {
  success: boolean;
  code?: string;
  error?: string;
}

interface CloudDownloadResult {
  success: boolean;
  filePath?: string;
  error?: string;
}

interface CloudListResult {
  success: boolean;
  files?: CloudFileEntry[];
  error?: string;
}

interface CloudDeleteResult {
  success: boolean;
  error?: string;
}

interface CloudProgressPayload {
  operation: "upload" | "download" | "delete";
  container: string;
  filename: string;
  progress: number;
  status: "started" | "success" | "error";
  error?: string;
}

interface CloudContext {
  upload: (request: CloudUploadRequest) => Promise<CloudUploadResult>;
  download: (request: CloudDownloadRequest) => Promise<CloudDownloadResult>;
  list: (request: CloudListRequest) => Promise<CloudListResult>;
  delete: (request: CloudDeleteRequest) => Promise<CloudDeleteResult>;
  writeTempFile: (content: string, filename: string) => Promise<{ success: boolean; filePath?: string; error?: string }>;
  readTempFile: (filePath: string) => Promise<{ success: boolean; content?: string; error?: string }>;
  deleteTempFile: (filePath: string) => Promise<{ success: boolean; error?: string }>;
  directUpload: (content: string, filename: string, container: string, reference: string) => Promise<CloudUploadResult>;
  onProgress: (handler: (payload: CloudProgressPayload) => void) => () => void;
}

interface AzureUploadRequest {
  containerName: string;
  fileName: string;
  fileContent: string;
  contentType: string;
}

interface AzureUploadResult {
  success: boolean;
  cloudUrl?: string;
  fileName?: string;
  error?: string;
}

interface ElectronAPI {
  uploadFileToAzure: (request: AzureUploadRequest) => Promise<AzureUploadResult>;
}

interface SharePointAPI {
  addRommEntry: (formData: {
    "romm-id": string;
    workspace: string;
    description: string;
    assertion: string;
  }) => Promise<{ success: boolean; data?: any; error?: string }>;
  updateRommEntry: (updateData: {
    rommId: string;
    assessment: string;
    documentation: string;
    controlIds?: string[];
    procedureIds?: string[];
  }) => Promise<{ success: boolean; data?: any; error?: string }>;
  readRommLibrary: () => Promise<{ success: boolean; data?: any; error?: string }>;
  readRommLibraryByWorkspace: (workspace: string) => Promise<{ success: boolean; data?: any; error?: string }>;
  uploadFile: (uploadData: {
    fileContent: string; // base64 content
    fileName: string;
    referenceValue?: string;
    folderName?: string;
    fyYear?: string;
  }) => Promise<{ success: boolean; data?: any; error?: string }>;
  loadCloudFiles: () => Promise<{ success: boolean; data?: any; error?: string }>;
  loadClientFiles: () => Promise<{ success: boolean; data?: any; error?: string }>;
  loadExcelColumns: (fileName: string) => Promise<{ success: boolean; data?: any; error?: string }>;
  executeIPE: (payload: { payrollFile: string; customKeys: string[] }) => Promise<{ success: boolean; data?: any; error?: string }>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  planning: PlanningContext;
  documents: DocumentsContext;
  internalControls: InternalControlsContext;
  cloud: CloudContext;
  electronAPI: ElectronAPI;
  sharePointAPI: SharePointAPI;
  payroll: {
    acceptedInputs: () => Promise<string[]>;
    run: (
      scriptKey: string,
      args: { inputFiles: string[]; options?: Record<string, unknown> },
    ) => Promise<{ ok: boolean; runId?: string; error?: string }>;
    listResults: () => Promise<
      Array<{ id: string; label: string; createdAt: number; filePath: string; size: number; mimeType?: string }>
    >;
    downloadResult: (id: string) => Promise<{ ok: boolean; filePath?: string; error?: string }>;
    loadExcelColumns: (fileName: string) => Promise<{ ok: boolean; columns?: string[]; error?: string }>;
    onProgress: (
      handler: (payload: { runId: string; progress: number; status: "running" | "success" | "error"; message?: string; error?: string }) => void,
    ) => () => void;
  };
}
